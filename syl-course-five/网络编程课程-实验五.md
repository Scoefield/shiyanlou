---
show: step
version: 1.0
enable_checker: true
---

# 并发服务编程实现

## 实验介绍

本实验主要介绍什么是并发服务以及代码实现。

#### 知识点

- 进程、线程和协程的介绍
- 多进程并发服务
- 多线程并发服务
- 多协程并发服务
- 多路 I/O 转接服务

## 进程、线程和协程的介绍

#### 什么是进程

众所周知，计算机的核心是 CPU，它主要负责程序的所有计算任务；而进程则是一个具有一定独立功能的程序，也可以理解为在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是一种抽象的概念，一般由程序、数据集合和程序控制块三部分组成。

- 程序用于描述进程要完成的功能，是控制进程执行的指令集；
- 数据集合是程序在执行时所需要的数据和工作区；
- 程序控制块（简称 PCB），它包含进程的描述信息和控制信息，是进程存在的唯一标志。

#### 什么是线程

线程也是操作系统提供的一种抽象概念，是程序执行中一个比较单一的顺序控制流程，即程序执行流的最小单元，可以理解为处理器调度和分派的基本单位。一个进程可以有一个或多个线程，同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈和线程本地存储。

同样，操作系统也会为线程分配一个线程控制块（简称 TCB），将所有用于控制和管理线程的信息记录在线程的控制块中，TCB 中通常包括以下几个部分：

- 线程标志符
- 一组寄存器
- 线程运行状态
- 优先级
- 线程专有存储区等

线程也具有这几种状态：初始态、就绪状态、等待（阻塞）状态、执行状态和终止状态，线程的生命周期如下图所示：

![1](./images/5-1.jpeg)

#### 什么是协程

协程又称微线程，顾名思义协程是一种比线程更加轻量级的执行过程，不是被操作系统内核所管理，而完全是由程序所控制，即基于用户态的。

可以理解为一个线程中有多个子程序，但执行过程中，子程序内部可中断，然后转而执行别的子程序，在执行完别的子程序后再返回来继续执行刚刚中断的子程序。协程之间的切换不需要涉及任何系统调用或任何阻塞调用，即协程只在一个线程中执行，是子程序之间的切换，发生在用户态上，而且线程的阻塞状态是由操作系统内核来完成，发生在内核态上，因此协程相比线程节省了线程创建和切换的开销。

协程一般适用于 IO 阻塞且需要大量并发的场景，当发生 IO 阻塞，由协程的调度器进行调度，通过将数据流中断掉，并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复协程栈，并把阻塞的结果放到这个线程上去运行。

#### 进程、线程以及协程之间的关系

操作系统中协程、线程以及进程的关系见下图所示：

![2](./images/5-2.jpeg)

## 多进程并发服务实现

使用多进程并发服务器时要考虑以下几点：

1. 父进程最大文件描述个数（父进程中需要 close 关闭 accept 返回的新文件描述符）
2. 系统内创建进程个数（与内存大小相关）
3. 进程创建过多是否降低整体服务性能（进程调度）

#### 基于 C 语言实现

以下是基于 C 语言实现多进程并发服务通信。

- 服务端 server

```c
#include <stdio.h>
```

- 客户端 client

```c
/*
    file: udp-client.c
*/

#include <stdio.h>

```

## 多线程并发服务实现

在使用线程模型开发服务器时需考虑以下问题：

1. 调整进程内最大文件描述符上限
2. 线程如有共享数据，考虑线程同步
3. 服务于客户端线程退出时，退出处理。（退出值，分离态）
4. 系统负载，随着链接客户端增加，导致其它线程不能及时得到 CPU

#### 基于 C 语言实现

- 服务端 server

```C
/*
    file: multithread-server.c
*/

#include <stdio.h>

```

- 客户端 client

```c
/*
    file: duobo-client.c
*/

#include <netinet/in.h>
```

## 多协程并发服务

#### 基于 Go 语言实现

- 服务端 server


- 客户端 client



## 多路 I/O 转接服务实现

休闲鞋

#### 基于 C 语言实现

- 服务端 server

```c
/*
    file: domain-server.c
*/

#include <stdlib.h>
```

- 客户端 client

```c
/*
    file: domain-client.c
*/

#include <stdio.h>
```

#### 基于 C 语言实现

- 服务端 server

```c
/*
    file: domain-server.c
*/

#include <stdlib.h>
```

- 客户端 client

```c
/*
    file: domain-client.c
*/

#include <stdio.h>
```

## 实验总结

以上是 UDP Socket 编程的相关实现说明，通过学习完本实验，大家可以发现，大部分的代码实现是上一个实验有讲到过的，只有少部分的实现方式和用法有点不一样，注释里也有说明，换汤不换药，说明前面的实验学习对后面的实战实验有一定帮助的。本实验也通过几个不同的案例实现，来讲解 UDP 的实现原理和具体使用方法，在网络编程中跟 TCP 同样重要，所以也希望同学们可以跟着实验一步一步地在电脑上敲一遍案例代码，并修改相应的变量或参数来达到运行的效果，进一步的巩固。
