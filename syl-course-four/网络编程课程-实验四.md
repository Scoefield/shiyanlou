---
show: step
version: 1.0
enable_checker: true
---

# UDP Socket 编程实现

## 实验介绍

本实验主要介绍网络套接字（Socket）和网络字节序，以及 Socket 网络模型的创建流程，最后分别通过 C 语言和 Go 语言来实现 TCP-C/S 模型，同时会提供完整的示例代码供大家学习和实操。

#### 知识点

- UDP 介绍
- UDP-C/S 模型实现
- 多播（组播）实现
- Socket IPC 实现

## UDP 的介绍

#### 什么是 UDP

前面实验一已经介绍过什么是 UDP 了，如果不记得的同学可以回顾下，这里再对 UDP 进行简单的介绍：UDP 是一种面向无连接的传输层协议，它不保证数据传输的可靠性，每个 UDP 报文分为 UDP 报头和 UDP 数据两部分。

在 OSI 网络模型中，传输层主要应用的协议模型有两种，一种是 TCP 协议，另外一种则是 UDP 协议。TCP 协议在网络通信中占主导地位，网络中的绝大多数通信都是基于 TCP 协议进行数据传输的，同样 UDP 也是网络通信中不可或缺的一种重要通信协议。

相对于 TCP 来说，UDP 通信的方式更像是发短信，在数据传输之前不需要事先建立连接，数据传输后也不用维护连接，只需专心获取和传输数据就好，即在通信过程中无需建立三次握手的过程，通信速度和效率有较大的提升，但 UDP 通信的稳定性不可靠，正确率也不能很好的得到保证。所以，我们称 UDP 为“面向无连接且不可靠的报文通信”。

那么与我们熟悉的 TCP 相比，UDP 有哪些优点和不足呢？  
由于 UDP 在传输数据前不需要创建连接，所以 UDP 的通信开销较小，数据传输速度快，实时性比较较强。多用于对实时性要求较高的通信场景，比如视频会议、电话语音等，但也伴随着数据传输的不可靠性，传输数据的正确率、传输顺序和流量都得不到很好的控制和保证。所以，通常情况下，使用 UDP 协议进行数据传输，为保证数据的正确性，我们需要在应用层添加辅助校验协议来弥补 UDP 的不足，以达到数据可靠传输的目的。

与 TCP 类似的，UDP 也会有丢包的现象，UDP 也有可能出现缓冲区被填满后再接收数据时丢包的现象。由于它没有 TCP 滑动窗口的机制，通常采用如下两种方法解决：

1. 一般会在服务器应用层设计流量控制，主要是控制发送数据的速度。
2. 另一个则是使用 setsockopt 函数来改变接收缓冲区的大小。如下所示：

```c
#include <sys/socket.h>

int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
int n = 220x1024
setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n));
```

其中 SO_RCVBUF 表示接收缓冲区，n 表示缓冲区设置的大小。`setsockopt` 函数的参数说明在实验二端口复用的那一小节有讲到，这里就不再赘述了，忘记了的同学可以回去复习下。

## UDP-C/S 模型实现

#### 基于 C 语言实现

首先 UDP 相对 TCP 来说通信连接是少了三次握手，也就是说之前 TCP 在服务端的 listen() 和 accept()函数可以不用了，在客户端的 connect() 函数也不用了，相关函数使用可以见上一实验说明。

- 服务端 server

```c
/*
    file: udp-server.c
*/

#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <ctype.h>

#define SERV_PORT 8000  // 定义服务端的端口号为 8000

int main(void)
{
    struct sockaddr_in serv_addr, clie_addr;    // 创建服务端地址和客户端地址的结构体变量
    socklen_t clie_addr_len;
    int sockfd;
    char buf[BUFSIZ];           // buf 缓冲区，最大值为 BUFSIZ，系统设置
    char str[INET_ADDRSTRLEN];  // 地址转网络字节序的长度
    int i, n;

    // 创建套接字 socket，即文件描述符，AF_INET 参数表示IPV4，下面会解释说明
    // SOCK_STREAM 表示流式协议 TCP 用的，这里用 SOCK_DGRAM 表示报式协议 UDP 用
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    // 清空地址结构、再进行地址相关赋值和转换，比如：地址族用 AF_INET 表示IPV4，htons 字节序转换，字节序相关可以参见前面的实验说明
    bzero(&serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port = htons(SERV_PORT);

    // 绑定服务器地址
    bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));

    printf("Accepting connections ...\n");
    while (1) {
        clie_addr_len = sizeof(clie_addr);
        // 在 TCP 是用 recv() 替换了原来使用的 read()，send()替换了write()，而在 UDP 是用 recvfrom() 和 sendto()
        // sockfd：套接字，buf：缓冲区地址，BUFSIZ：缓冲区大小，0：默认值，clie_addr：传出参数客户端（对端）地址结构，clie_addr_len：传出地址长度
        // 返回值：成功接收数据的字节数，失败：-1，0 的话表示对端关闭
        n = recvfrom(sockfd, buf, BUFSIZ, 0, (struct sockaddr *)&clie_addr, &clie_addr_len);
        if (n == -1)
            perror("recvfrom error");

        // 打印接收客户端的信息
        printf("received from %s at PORT %d\n", inet_ntop(AF_INET, &clie_addr.sin_addr, str, sizeof(str)), ntohs(clie_addr.sin_port));
        // 处理数据：小写转大写
        for (i = 0; i < n; i++)
            buf[i] = toupper(buf[i]);

        // 发送回给客户端
        // sockfd：套接字，buf：存储数据的缓冲区，n：数据长度，clie_addr：传入参数目标（对端）地址结构，sizeof(clie_addr)：地址结构长度
        // 返回值：成功写出的字节数，失败：-1
        n = sendto(sockfd, buf, n, 0, (struct sockaddr *)&clie_addr, sizeof(clie_addr));
        if (n == -1)
            perror("sendto error");
    }

    // 最后关闭文件描述符
    close(sockfd);

    return 0;
}
```

通过以上程序可以看到 UDP 服务端代码在实现上与上一实验 TCP 的代码实现有异曲同工之处，不同的地方前面也已经提到了，主要是 UDP 通信连接不用三次握手。  
UDP 服务端代码相关说明已经写到注释里了，如果大家对函数的使用和参数说明还不是很清楚的，可以回顾前面实验学的 TCP 通信的实现说明，或者可以通过以下的方式来查看函数说明。

`socket`函数里的参数可以通过命令`man socket`来查看，如下图所示：

![1](./images/4-1.jpeg)

可以看到里面的函数说明都是英文的，大概意思看懂就行，当然也可以复制相应的内容到翻译器去翻译阅读。

同样 `recvfrom` 函数和 `sendto` 函数也可以通过命令 `man recvfrom` 或 `man sendto` 来查看参数说明，要学会举一反三，这里就不一一列举说明了。

- 客户端 client

```c
/*
    file: udp-client.c
*/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <ctype.h>

#define SERV_PORT 8000

int main(int argc, char *argv[])
{
    // 定义相关结构和缓冲变量
    struct sockaddr_in servaddr;
    int sockfd, n;
    char buf[BUFSIZ];

    // 同样客户端也要创建套接字（文件描述符），参数说同服务器端
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    // 清空地址结构，再对地址结构进行相关赋值
    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    inet_pton(AF_INET, "127.0.0.1", &servaddr.sin_addr);
    servaddr.sin_port = htons(SERV_PORT);

    // 绑定通信地址，客户端的 bind() 可有可无，因为下面 sendto() 函数的参数 &servaddr 已指定了服务器的地址结构了
    bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr));

    while (fgets(buf, BUFSIZ, stdin) != NULL) {
        // 发送数据给服务端
        n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&servaddr, sizeof(servaddr));
        if (n == -1)
            perror("sendto error");

        // 接收数据，参数NULL：表示不关心对端信息
        n = recvfrom(sockfd, buf, BUFSIZ, 0, NULL, 0);
        if (n == -1)
            perror("recvfrom error");

        write(STDOUT_FILENO, buf, n);
    }

    // 关闭文件描述符
    close(sockfd);

    return 0;
}
```

同样，UDP 的客户端相关函数使用跟服务端的大同小异，在服务端代码实现的注释里已经写得很详细了，客户端的代码解释可以参考服务端的。

通过编译并执行 UDP 服务端和客户端程序，编译服务端程序命令为 `gcc -o udp-server udp-server.c`，编译客户端命令为 `gcc -o udp-client udp-client.c`，编译后先运行服务端程序 `./udp-server`，再运行客户端程序 `./udp-client`，运行情况如下图所示：

![2](./images/4-2.jpeg)

以上 UDP 通信主要是实现：客户端终端输入字符串数据发送给服务端，服务端接收到数据后转换为大写，再发送回给客户端，客户端接收到服务端处理后发回来的数据后，打印出来。  
当然也可以开启多个客户端跟服务端进行通信，发送和接收数据。

#### 基于 Go 语言实现

- 服务端 server

```go
/*
    file: udp-server-go.go
*/
package main

import (
    "fmt"
    "net"
)

func main() {
    // 1、创建一个 *UDPAddr，即一个 udp 地址结构，传入 udp 协议并指定服务器的 IP 和 port，这里的端口为8000
    udpAddr, err := net.ResolveUDPAddr("udp", "127.0.0.1:8000")
    if err != nil {
        fmt.Printf("net.ResolveUDPAddr() 函数执行出错, 错误信息为: %v\n", err)
        return
    }
    fmt.Println("UDP 服务器地址结构创建成功!")

    // 2、创建服务端（用户通信）的 socket，将第一步创建的 *UDPAddr类型的参数传入
    udpSocket, err := net.ListenUDP("udp", udpAddr)
    if err != nil {
        fmt.Printf("net.ListenUDP()函数执行出错,错误为:%v\n", err)
        return
	}
	// 利用 defer 延迟关闭 udpSocket，即函数执行完后关闭
    defer udpSocket.Close()
    fmt.Println("UDP 服务器端通信的 socket 创建成功，等待客户端连接...")

    // 3、创建 buf 缓冲区存放读取客户端发送的数据
    buf := make([]byte, 4096)
    // ReadFromUDP()方法会返回三个值，分别是读取到的字节数、客户端的地址以及error；ReadFromUDP()方法会阻塞，直到客户端连接进来
	n, clientUDPAddr, err := udpSocket.ReadFromUDP(buf)
    if err != nil {
        fmt.Printf("ReadFromUDP()方法执行出错，错误信息为:%v\n", err)
        return
	}
	fmt.Println("连接成功，客户端地址为：", clientUDPAddr)

    // 4、模拟处理读取到客户端的数据
    fmt.Printf("服务器读到[%v]发送过来的数据为: %s", clientUDPAddr, buf[:n])

    // 5、处理完数据后，回写数据给客户端，这里随便写了一个字符串过去，使用 WriteToUDP() 方法
    _, err = udpSocket.WriteToUDP([]byte("Data processing completed!"), clientUDPAddr)
    if err != nil {
        fmt.Printf("WriteToUDP()方法执行出错，错误信息为:%v\n", err)
        return
    }
}
```

- 客户端 client

```go
/*
    file: udp-client-go.go
*/
package main

import (
    "fmt"
    "net"
)

func main() {
	// 1、创建客户端连接，返回创建的连接结构 conn，注意这里的端口要与服务端对应（8000）
    conn, err := net.Dial("udp", "127.0.0.1:8000")
    if err != nil {
        fmt.Printf("net.Dial()函数执行出错,错误信息为:%v\n", err)
        return
	}
	// 同样也是利用 defer 延迟关闭 udpSocket，即函数执行完后关闭
    defer conn.Close()

	// 2、客户端写数据到服务端
    conn.Write([]byte("Hello, this is udp-client send message."))

	// 3、发送完数据后创建一个缓冲区 buf 来存储从服务端读回来的数据
    buf := make([]byte, 4096)
    n, err := conn.Read(buf)
    if err != nil {
        fmt.Printf("Conn.Read()方法执行出错，错误信息为:%v\n", err)
        return
	}
	// 打印读取到的数据
    fmt.Printf("从服务器读取到的数据为：%s\n", buf[:n])
}
```

以上是用 Go 语言实现的 UDP 服务端和客户端程序，代码相关解释说明已写到注释里了，可以看到相对用 C 语言实现 UDP-C/S 模型来说，会比较简洁易懂。  
通过执行命令`go run udp-server-go.go` 和 `go run udp-client-go.go` 运行以上程序，结果如下图所示：

![3](./images/4-3.jpeg)

## 多播（组播）的实现

#### 基于 C 语言实现

- 服务端 server

```C

```

- 客户端 client
  xxx

## 本地套接字 domain（socket IPC）实现

#### 基于 C 语言实现

- 服务端 server
  xxx

- 客户端 client
  xxx

## UDP 与 TCP 的区别

xxx

## 实验总结

通过学习完本实验，可以让大家了解到什么是套接字（Socket）、网络字节序和粘包等，另外，在介绍 TCP 网络 C/S 模型的同时，会提供示例代码的讲解以及运行结果的描述，帮助大家更好的理解和熟悉。TCP 网络编程是整个网络编程实验的核心，希望同学们可以跟着实验一步一个脚印的坚持学习下去，实验中的每个示例代码都跟着在机子上敲一遍，运行查看结果，并学会举一反三。
