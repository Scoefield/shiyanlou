---
show: step
version: 1.0
enable_checker: true
---

# 使用 Socket 实现并发通讯服务案例

## 实验介绍

本实验主要介绍基于 Go 语言如何用 Socket 编程知识实现并发通讯服务的案例，从而让大家巩固下前面所学的知识，达到学有所用的效果。另外本实验要求需要有 Go 语言的基础，对 Go 语言基本语法有一定的了解。

#### 知识点

- TCP Socket 编程简单回顾
- 并发通讯服务案例实现（基于 Go 语言）

## TCP Socket 编程的简单流程回顾

#### 服务端的简单处理流程

1. 监听端口，比如：8080
2. 建立客户端和服务的 TCP 连接
3. 创建协程（goroutine），处理客户端请求

#### 客户端的简单处理流程

1. 建立与服务端之间的连接
2. 发送请求数据
3. 接收服务端返回的结果
4. 关闭与服务端之间的连接

#### 简单程序流程示意图如下所示

![1](./images/7-1.png)

以上示意图的代码实现已经在前面实验三“基于 Go 语言实现客户端/服务器端程序”的那小节讲过，这里就不再赘述了，忘记的同学可以回顾一下。

## 并发通讯服务案例实现（基于 Go 语言实现）

接下来我们通过一个案例来说明如何实现并发通讯服务。

#### 并发通讯服务案例的主要功能说明

实现一个服务端（通讯服务）与多个客户端（用户）之间建立连接，建立连接成功后，客户端之间可以在一个通讯服务（聊天室）里进行通讯，可以理解为在一个群里聊天了，而服务端就是一个群聊的后台服务，实时且并发的处理每个客户端发送的通讯消息（数据），从而实现并发的通讯服务案例。

#### 并发通讯服务流程示意图如下所示

![2](./images/7-2.png)

#### 服务器端主要流程

1. 打印提示监听端口的信息
2. 开始监听端口，这里的案例监听的是 8080 端口
3. 监听成功后，开始循环等待客户端连接的到来
4. 每一个客户端连接成功，都会将客户端加入客户端全局队列，其目的是后面会广播消息到该全局队列的所有客户端
5. 客户端加入通讯服务后，开始广播该客户端加入通讯服务的消息到客户端全局队列，即通知每个客户端有新的客户端加入（上线）了
6. 然后服务端会单独开启一个协程（微线程）处理与当前连接成功的客户端之间的通讯，即每一个客户端与服务端建立连接成功后，服务端都会开启一个协程对应处理它们之间的通讯

以上就是服务端实现并发通讯服务的主流程，需要说明的是：  
- 这里的客户端也可以理解为用户
- 协程、线程和进程的区别在前面实验五已经有解释说明，这里也不再赘述了

服务器端主要流程代码实现如下：

```go
// 服务端主函数（入口函数）
func main() {
	// 1. 提示信息
	fmt.Println("服务器在 8080 端口监听....")
	// 2. 服务端监听端口 8080
	listen, err := net.Listen("tcp", "0.0.0.0:8080")
	defer listen.Close()
	if err != nil {
		fmt.Println("net.Listen err=", err)
		return
	}

	// 3. 一旦监听成功，就等待客户端连接的到来
	fmt.Println("服务器等待客户端的连接.....")
	for {
        // 客户端连接到来之前，会阻塞在这里，连接成功后才往下走
		conn, err := listen.Accept()
		if err != nil {
			fmt.Println("listen.Accept err=" ,err)
		}

		// 4. 连接进来的客户端加入  用户(客户端)全局队列
		// 后面用于广播消息到该队列所有的客户端
		clientAddr := conn.RemoteAddr().String()
		var userProcess UserProcess
		userProcess.Conn = conn		// 当前连接
		userProcess.UserAddr = clientAddr	// 当前连接的客户端地址
		userKey := strings.Split(clientAddr, ":")[1]    // 当前连接的客户端端口号，用与标识是哪个客户端
		userMgr.onlineUsers[userKey] = &userProcess

		// 打印建立连接的信息
		fmt.Printf("客户端[%s]与服务端已建立连接.\n", clientAddr)

		// 5. 客户端加入通讯室时，广播该客户端加入的消息
		JoinOrLeaveMsg(userKey, clientAddr, ClientJoin)

		// 6. 一旦连接建立成功，则单独启动一个协程和客户端保持通讯
		go Process(conn, userKey)
	}
}
```

#### 客户端主要流程

1. 与服务器端建立连接，返回连接句柄 conn
2. 打印提示建立连接成功的信息
3. 客户端与服务器端进行通讯：单独开启一个协程用于接收服务器端发送过来的数据，而主协程主要处理发送消息

客户端主要流程代码实现如下：

```go
// 客户端主函数（入口函数）
func main() {
    // 1. 与服务端建立连接，返回连接句柄 conn
    conn, err := GetConnect()
    if err != nil {
        fmt.Println("GetConnect err=", err)
    }
    // 2. 打印提示建立连接成功并可以进行通讯的信息
    fmt.Println("与服务端建立连接成功，欢迎来到【ChatRoom】，现在可以进行通讯了.")
    // 3. 客户端处理进程
    ClientProcess(conn)
}

// 客户端处理函数，入参为：与服务端建立连接的句柄 conn
func ClientProcess(conn net.Conn) {
    // 3.1 单独开启一个协程用于接收服务端发送过来的数据
    go ClientReceiveMsg(conn)
    // 3.2 主协程处理发送数据
    ClientSendMsg(conn)
}
```

#### 发送或接收的消息体结构

服务器端广播发送消息和客户端接收消息时使用到该消息体结构

```go
// 消息结构体
type Message struct {
	DataSource string	`json:"data_source"`	// 消息（数据）来源
	Data string	`json:"data"`					// 消息（数据）内容
}
```



## 实验总结

以上是基于 Go 语言实现文件传输的案例，通过学习完本实验，大家可以知道将如何用 Go 语言对文件进行操作了，包括读、写和传输文件。本实验代码量相对前面实验说比较少，也比较简洁，但是对文件传输操作来说是比较经典的，希望同学们学完有所收获。
