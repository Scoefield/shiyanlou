---
show: step
version: 1.0
enable_checker: true
---

# TCP Socket 编程实现

## 实验介绍

关于网络编程其实在互联网中应用是非常广泛的，本实验将从网络编程的基础知识入手，主要介绍网络中的典型协议、端口、网络分层模型以及通信过程，为后续的实验打下基础。

#### 知识点

- 网络套接字
- 网络字节序
- Socket 模型创建流程
- TCP-C/S 模型实现

## 网络套接字

#### 套接字 Socket 的介绍

- 什么是 Socket

我们从英文的翻译可以知道 Socket 本身表示插座的意思。顾名思义，插座是可以用来充电的，而插孔就像端口一样，同一时间不能被其它进程占用，而我们建立网络连接就像把插头插在这个插座上一样，可以创建一个 Socket 实例来使用，从而进行网络中的数据传递。

在网络环境中，其实 Socket 就是我们平时所说的“套接字”，主要用于表示程序进程间网络通信的一种特殊文件类型。在 Linux 环境下，一切皆为文件，而 Socket 的本质则是内核中在缓冲区形成的一种伪文件。Socket 的类型既然是属于文件，那么理所当然的，我们就可以使用文件描述符来引用 Socket。

由于 Socket 可以应用于网络进程间的通信（数据的传递），所以 Linux 系统内核为了对外统一接口调用，已经将 Socket 封装成了文件，对于开发者来说，读写 Socket 的操作就像跟读写文件的操作一样，有点类似与 Linux 环境中的管道，区别就是管道主要应用于本地进程间的通信，而 Socket 应用于网络进程间的数据传递比较多。

在 TCP/IP 协议的描述中，网络应用中的一个进程是由 IP 地址+TCP 或 UDP 中的端口号来唯一标识的，即`IP:PORT`表示，也可以把该进程理解为一个 Socket。同样，如果要想在两个进程间建立连接来进行通信，则需要在两个进程各自创建一个 Socket 来标识，这样两个进程中的 Socket 就组成了一个 Socket 对，那么这个 Socket 对也就唯一标识了一个网络连接，因此也就可以用 Socket 来描述网络连接的一对一关系了。

我们经常说到的 Socket 在网络通信中的位置可以参考下图：

![1](./picture3/socket-sit.png)

事实上，Socket 是一个封装好的抽象层，主要作用于应用层和传输层之间。也可以把 Socket 看作是应用层和传输层之间的通信介质，它把网络中数据传递的复杂操作抽象为几个简单的函数或者说是接口（API），提供给应用层和传输层使用，实现网络进程间的通信（数据传递）。

Socket 的由来可以说是起源于 UNIX，前面提到过，在 Unix 环境一切皆文件的设计思想下，进程间的通信就可以理解为对文件描述符之间的一些操作。Socket 是一种类似可以操作文件那样：打开—读/写—关闭模式的实现，放到网络编程的中，就是服务器和客户端各自需要维护一个文件描述符，即图中提到的 ServerFd 和 ClientFd，在两端建立连接成功后，可以向“文件”写入内容供对方读取或者读取对方的内容，通信结束时就关闭“文件”，连接断开。

#### 网络套接字通信原理

通常不同机器上的应用程序（进程）之间是通过 Socket 来发送数据报文，从而来达到通信的目的。在网络通信过程中，Socket 是应用层和传输层之间的一道门，开发者可以操作应用层往传输层传递数据，Socket 在数据传递时会进行相应的处理，比如对数据进行包封装等。

服务器要想跟客户端建立连接并能够作出响应，必须要具备以下两个条件才可以：

1. 服务器端的程序（进程）不能处于休眠状态；
2. 服务器端的程序（进程）必须创建有套接字（Socket）。

套接字 Socket 的通信原理可以大致用下图的流程表示：

![2](./picture3/socket-sc.png)

由以上 Socket 通信图可知，在网络通信过程中，套接字需要是成对存在的，否则进程间将不能进行通信。一端（服务端）的发送缓冲区对应另一端（客户端）的接收缓冲区，各自都会维护的一个文件描述符来进行网络操作。

## 网络字节序

#### 网络字节序的介绍

网络字节序，从字面的意思理解就是在网络中字节存储的顺序，而在网络编程中实际指的就是大于一个字节类型的数据在内存中的存放顺序。

我们知道，内存地址有高地址位和低地址位之分，平时开发中操作内存地址时，多字节数据相对于内存地址会有大端和小端之分，同样，在网络中数据流存放也有大端和小端之分，那么什么是大端，什么又是小端呢？

一般不同的电脑主机会有不同的网络字节序，确切的说不同的 CPU 会有不同的字节序类型，这些字节序是指数据在内存中保存的顺序，这个也叫做主机序。最常见的主机序有以下两种：

1. 小端字节序（Little endian） ：将高位字节存储在内存的高地址处，而低位字节存储在内存的低地址处。
2. 大端字节序（Big endian） ：将高位字节存储在内存的低地址处，低位字节存储在内存的高地址处。

另外，网络传输的数据流是按照这么个顺序发送和接收的：发送主机通常会按内存地址从低到高将发送存放区（缓冲区）中的数据发送出去，接收主机则也会按内存地址从低到高的顺序把从网络中接收到的数据，以字节的形式保存在接收缓冲区中，因此，网络数据流通常规定低地址先发出数据，高地址后发出数据。

但是，需要注意的是，在网络程序开发亦或是在跨平台开发时，应当尽可能的保持只用一种字节序，否则网络通信双方对数据的解析就会有所不一样，从而会产生问题。
实际上，在平时程序开发中，大多数人都很少会直接操作字节序，因为有已经封装好相应的库来间接的操作字节序，而且在跨平台以及网络程序开发中，字节序才会被考虑应用进来。

为了在开发中使网络程序更具有通用性和可移植性，在编写 C 代码时，可以使用以下封装好的库函数来做主机字节序和网络字节序之间的转换，这样无论在大端和小端的机器上编译后，都可以正常运行。

```c
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostlong);      // 将 long 类型从主机序转换为网络序
uint16_t htons(uint16_t hostshort);     // 将 short 类型从主机序转换为网络序
uint32_t ntohl(uint32_t netlong);       // 将 long 类型从网络序转换为主机序
uint16_t ntohs(uint16_t netshort);      // 将 short 类型从网络序转换为主机序
```

以上的库函数也比较好记，htonl 的前缀 h 表示主机（host）的意思，ntohl 的前缀 n 表示网络（network）的意思，这两个函数的后缀 l 表示长整数（long），s 则表示短整数（short）。

那么怎么查看自己的机器是大端模式还是小端模式呢，下面通过一个小案例来给大家讲解下：

先来看看以下的示例代码（c++）：

```c++
#include <iostream>
using namespace std;

// 判断大小端函数
void judge_big_little_end()
{
    cout << "本机器的字节序模式为：";
    int i = 1;                      // 定义 int 变量 i
    char c = *(char*)&i;          // 将 i 的地址强转为 char* 类型，为了能够拿到 i 的地址

    // 如果为 1，则为小端存储模式，否则为大端模式
    if (c)
        cout << "小端" <<endl;
    else
        cout << "大端" <<endl;
}

// 主函数
int main()
{
    // 调用判断大小端的函数
    judge_big_little_end();
    return 0;
}
```

通过代码的注释可以知道，判断是大端还是小端模式可以简单总结为以下步骤：

1. 定义一个整型（int）变量 i，赋值为 1;
2. 将 i 的地址拿到后（&i），强制转为 char\* 类型，此时就可以拿到 i 的低地址了；
3. 然后再进行判断，如果低地址是 1 ，则就是小端模式存放，如果是 0 ，则就是大端模式了。

## 网络套接字 Socket 模型

#### 模型的创建流程

#### 模型的函数解析

TCP/IP 网络协议栈分为应用层、传输层、网络层和链路层四层，一般在应用开发过程中，讨论最多的是 TCP/IP 模型。四层模型如下图所示：

## TCP-C/S 模型实现

#### 基于 C 语言实现

- 服务端 server

- 客户端 client

#### 基于 Go 语言实现

- 服务端 server

- 客户端 client

## TCP 粘包

#### 粘包的介绍

#### 粘包示例代码（Go 语言实现）

#### 解决粘包的方法

## 实验总结

网络的核心基础是一系列协议，而网络编程则是基于这些协议，对网络中的数据进行处理传输等。掌握好网络编程的基础，意味着为后面实操网络编程的实验做准备，希望同学们能够沉下心来把基础打牢。
