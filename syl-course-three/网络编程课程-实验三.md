---
show: step
version: 1.0
enable_checker: true
---

# TCP Socket 编程实现

## 实验介绍

关于网络编程其实在互联网中应用是非常广泛的，本实验将从网络编程的基础知识入手，主要介绍网络中的典型协议、端口、网络分层模型以及通信过程，为后续的实验打下基础。

#### 知识点

- 网络套接字
- 网络字节序
- Socket 模型创建流程
- TCP-C/S 模型实现

## 网络套接字

#### 套接字 Socket 的介绍

- 什么是 Socket

我们从英文的翻译可以知道 Socket 本身表示插座的意思。顾名思义，插座是可以用来充电的，而插孔就像端口一样，同一时间不能被其它进程占用，而我们建立网络连接就像把插头插在这个插座上一样，可以创建一个 Socket 实例来使用，从而进行网络中的数据传递。

在网络环境中，其实 Socket 就是我们平时所说的“套接字”，主要用于表示程序进程间网络通信的一种特殊文件描述。在 Linux 环境下，一切皆为文件，而 Socket 的本质则是内核中在缓冲区形成的一种伪文件。Socket 的类型既然是属于文件，那么理所当然的，我们就可以使用文件描述符来引用 Socket。

由于 Socket 可以应用于网络进程间的通信（数据的传递），所以 Linux 系统内核为了对外统一接口调用，已经将 Socket 封装成了文件，对于开发者来说，读写 Socket 的操作就像跟读写文件的操作一样，有点类似与 Linux 环境中的管道，区别就是管道主要应用于本地进程间的通信，而 Socket 应用于网络进程间的数据传递比较多。

在 TCP/IP 协议描述中，网络应用中的一个进程是由 IP 地址+TCP 或 UDP 中的端口号来唯一标识的，即`IP:PORT`，也可以把该进程理解为一个 Socket。同样，如果要想在两个进程间建立连接来进行通信，则需要在两个进程各自创建一个 Socket 来标识，这样两个进程中的 Socket 就组成了一个 Socket 对，那么这个 Socket 对也就唯一标识了一个网络连接，因此也就可以用 Socket 来描述网络连接的一对一关系了。

事实上，Socket 是一个封装好的抽象层，主要作用于应用层和传输层之间。也可以把Socket看作是应用层和传输层之间的通信介质，它把网络中数据传递的复杂操作抽象为几个简单的函数或者说是接口（API），提供给应用层和传输层使用，实现网络进程间的通信（数据传递）。

Socket 的背景可以追溯于 UNIX，前面提到过，在 Unix 环境一切皆文件的设计思想下，进程间的通信就可以理解为对文件描述符之间的一些操作。Socket 是一种类似操作文件那样：打开—读/写—关闭模式的实现，用网络编程的思想来说就是服务器和客户端各自维护一个文件描述符，在两端建立连接成功后，可以向“文件”写入内容供对方读取或者读取对方的内容，通信结束时就关闭“文件”，连接断开。

我们经常说到的 Socket 所在位置可以参考下图：

![1](./picture3/socket-sit.png)

#### 网络套接字通信原理

运行在不同机器上的进程彼此通过向套接字发送报文来进行通信。每个进程好比是一座房子，进程的套接字就好比是一个门。套接字是应用进程和 TCP 之间的门，应用程序开发者可以控制套接字的应用层那一侧所有的东西，但是不能控制运输层那一侧。
服务器为了能对客户机程序发起连接作出响应，应满足：
第一、服务器程序不能处于休眠状态；
第二、服务器程序必须有某种套接字。

在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。
TCP/IP 协议最早在 BSD UNIX 上实现，为 TCP/IP 协议设计的应用层编程接口称为 socket API。

套接字 Socket 的通信原理大致如下图所示：

![2](./picture3/socket-sc.png)

## 网络字节序

#### 网络字节序的介绍

字节序，顾名思义字节的顺序，在网络编程中指的就是大于一个字节类型的数据在内存中的存放顺序。

我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。

不同的 CPU 有不同的字节序类型 这些字节序是指整数在内存中保存的顺序 这个叫做主机序
最常见的有两种
1 ． Little endian ：将低序字节存储在起始地址
2 ． Big endian ：将高序字节存储在起始地址

同样 在网络程序开发时 或是跨平台开发时 也应该注意保证只用一种字节序 不然两方的解释不一样就会产生 bug。
其实大部分人在实际的开发中都很少会直接和字节序打交道。唯有在跨平台以及网络程序中字节序才是一个应该被考虑的问题。

TCP/IP 协议规定，网络数据流应采用大端字节序，即低地址高字节。例如上一节的 UDP 段格式，地址 0-1 是 16 位的源端口号，如果这个端口号是 1000（0x3e8），则地址 0 是 0x03，地址 1 是 0xe8，也就是先发 0x03，再发 0xe8，这 16 位在发送主机的缓冲区中也应该是低地址存 0x03，高地址存 0xe8。但是，如果发送主机是小端字节序的，这 16 位被解释成 0xe803，而不是 1000。因此，发送主机把 1000 填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到 16 位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32 位的 IP 地址也要考虑网络字节序和主机字节序的问题。
为使网络程序具有可移植性，使同样的 C 代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。

```c
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostlong);      // 将 unsigned long 类型从主机序转换为网络序
uint16_t htons(uint16_t hostshort);     // 将 unsigned short 类型从主机序转换为网络序
uint32_t ntohl(uint32_t netlong);       // 将 unsigned long 类型从网络序转换为主机序
uint16_t ntohs(uint16_t netshort);      // 将 unsigned short 类型从网络序转换为主机序
```

h 表示 host，n 表示 network，l 表示 32 位长整数（long），s 表示 16 位短整数（short）。
如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。

现代 CPU 的累加器一次能装载至少 4 字节，即一个整数。那么这 4 个 字节在内存中的排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。字节序分为大端字节序 (即大端模式，Big endian) 和 小端字节序 (即小端模式，Little endian)。

大端字节序：整数的高位字节存储在内存的低地址处，低位字节存储在内存的高地址处。
小端字节序：整数的高位字节存储在内存的高地址处，而低位字节存储在内存的低地址处。

## 网络套接字 Socket 模型

#### 模型的创建流程

#### 模型的函数解析

TCP/IP 网络协议栈分为应用层、传输层、网络层和链路层四层，一般在应用开发过程中，讨论最多的是 TCP/IP 模型。四层模型如下图所示：

## TCP-C/S 模型实现

#### 基于 C 语言实现

- 服务端 server

- 客户端 client

#### 基于 Go 语言实现

- 服务端 server

- 客户端 client

## TCP 粘包

#### 粘包的介绍

#### 粘包示例代码（Go 语言实现）

#### 解决粘包的方法

## 实验总结

网络的核心基础是一系列协议，而网络编程则是基于这些协议，对网络中的数据进行处理传输等。掌握好网络编程的基础，意味着为后面实操网络编程的实验做准备，希望同学们能够沉下心来把基础打牢。
